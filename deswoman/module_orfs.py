import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from deswoman.module_colors import openFile


__author__ = "Anna Grandchamp"
__contributor__ = ""
__copyright__ = ""
__credits__ = []
__license__ = ""
__version__ = "1.0.0"
__maintainer__ = "Anna Grandchamp"
__email__ = "anna.grandchamp@inserm.fr"


def extract_orfs(sequence: str, transc_name: str, dico_orfs: dict) -> None:
    """
    Extracts Open Reading Frames (ORFs) from a given transcript sequence based on start and stop codons.

    This function identifies potential ORFs in the provided nucleotide sequence by scanning for
    the start codon "ATG" and one of the stop codons ("TAG", "TAA", "TGA"). It collects ORFs with lengths
    greater than a minimum threshold and stores them in a dictionary with unique names. The function
    processes the sequence in different reading frames (starting at positions 0, 1, or 2) and allows for a
    maximum ORF size limit.

    Parameters:
    -----------
    sequence : str
        A nucleotide sequence (DNA or RNA) from which ORFs are to be extracted.

    transc_name : str
        The name of the transcript to which the ORFs belong. This will be used to generate unique ORF names.

    dico_orfs : dict
        A dictionary that will be populated with ORFs. The keys will be ORF names (generated using the transcript name and positions),
        and the values will be the corresponding ORF sequences.

    Returns:
    --------
    None
        The function updates the `dico_orfs` dictionary with the extracted ORFs. It does not return any value directly.

    Notes:
    ------
    - The function processes the sequence in three frames (0, 1, 2), and each frame starts at a different offset in the sequence.
    - The function looks for ORFs that are at least `min_size` (91) nucleotides long and no longer than `max_size` (9000).
    - Each ORF is identified by the presence of the "ATG" start codon and one of the stop codons ("TAG", "TAA", "TGA").
    - The ORFs are stored in `dico_orfs` with a unique key generated by combining the transcript name and the ORF's start and stop positions.
    """
    list_stops = ["TAG", "TAA", "TGA"]
    min_size = 91
    max_size = 9000
    compteur = 1

    start_pos = 0
    ## Frame 1
    if len(sequence) >= min_size:
        while start_pos < 3:
            iter = start_pos
            while iter < (
                len(sequence) + 1 - min_size
            ):  # in range(start_pos, (len(sequence)+1-min_size), 3):
                start = sequence[iter : iter + 3].upper()
                stop_attributed = False
                if start == "ATG":
                    for iter2 in range((iter + 3), iter + max_size, 3):
                        if iter2 + 2 < len(sequence):
                            stop = sequence[iter2 : iter2 + 3].upper()
                            if stop in list_stops:
                                if (iter2 + 3 - iter) < min_size:
                                    break
                                else:
                                    my_orf = sequence[iter:iter2]
                                    official_start = str(iter + 1)
                                    official_stop = str(iter2)
                                    new_orf_name = (
                                        transc_name
                                        + "_"
                                        + str(compteur)
                                        + "_"
                                        + official_start
                                        + "_"
                                        + official_stop
                                    )
                                    dico_orfs[new_orf_name] = my_orf
                                    compteur += 1
                                    stop_attributed = True
                                    break
                        else:
                            break
                if stop_attributed == True:
                    iter = iter2 + 3
                else:
                    iter += 3
            start_pos += 1


def my_get_orfs(name_output_directory: str) -> dict:
    """
    Extracts all Open Reading Frames (ORFs) from all transcripts in a FASTA file.

    This function processes the transcripts contained in a specified FASTA file (denovo_transcript.fa)
    located in the provided directory. For each transcript, it calls the `extract_orfs` function to
    identify and extract all potential ORFs from the sequence, which are then stored in a dictionary
    for later use.

    The function also deletes the FASTA file after processing to clean up.

    Parameters:
    -----------
    name_output_directory : str
        The path to the directory containing the `denovo_transcript.fa` file. This file should contain
        the transcript sequences in FASTA format.

    Returns:
    --------
    dico_orfs : dict
        A dictionary where the keys are ORF names (generated using the transcript ID and the ORF positions)
        and the values are the corresponding ORF sequences.
    """
    file_name = name_output_directory + "/denovo_transcript.fa"
    dico_orfs = {}
    c = 1
    check_file = os.stat(file_name).st_size
    if check_file != 0:
        for seq_record in SeqIO.parse(file_name, "fasta"):
            ID_seq = str(seq_record.id)
            sequence = str(seq_record.seq)
            extract_orfs(sequence, ID_seq, dico_orfs)
    os.remove(file_name)
    return dico_orfs


def build_dict_orfs_per_transcript(dict_orfs: dict) -> dict:
    """
    Creates a dictionary that maps transcripts to their corresponding ORFs.

    This function takes a dictionary of ORFs (where each key represents an ORF, and the value is the ORF sequence)
    and creates a new dictionary with transcript names as keys. Each transcript is associated with a list of ORF names
    that belong to it.

    Parameters:
    -----------
    dict_orfs : dict
        A dictionary where the keys are ORF names (which include the transcript ID),
        and the values are the corresponding ORF sequences.

    Returns:
    --------
    dict_transcrit_all_orfs : dict
        A dictionary where the keys are transcript names, and the values are lists of ORF names
        associated with each transcript.

    Example:
    --------
    If the input `dict_orfs` contains the following entries:
    {
        "transcript1_1_100_200": "ATGGGTTTAA",
        "transcript1_2_300_400": "ATGGGCCCAA",
        "transcript2_1_100_200": "ATGGGTTTAA"
    }

    The function will return:
    {
        "transcript1": ["transcript1_1_100_200", "transcript1_2_300_400"],
        "transcript2": ["transcript2_1_100_200"]
    }
    """
    # Initialize an empty dictionary to store transcripts and their corresponding ORFs
    dict_transcrit_all_orfs = {}

    # Iterate through each ORF in the input dictionary
    for orf in dict_orfs:
        # Extract the transcript name from the ORF
        transcript_name = orf.split("_")[0]

        # Update the dictionary with the transcript and its corresponding ORF
        if transcript_name not in dict_transcrit_all_orfs:
            dict_transcrit_all_orfs[transcript_name] = [orf]
        else:
            dict_transcrit_all_orfs[transcript_name].append(orf)

    # Return the dictionary with transcripts and their corresponding ORFs
    return dict_transcrit_all_orfs


class Gene:
    """
    A class representing a Gene, with its associated transcripts and ORFs.

    This class stores information about a gene, including its associated ORFs,
    the sequences of the ORFs, and the sequences of the transcripts that are related to the gene.

    Attributes:
    -----------
    dict_transcripts_assoc_orfs : dict
        A dictionary where keys are gene names, and the values are lists of ORF names associated with the gene.
    gene_name : str
        The name of the gene.
    dict_orf_seq : dict
        A dictionary where keys are ORF names, and the values are the corresponding ORF sequences.
    dict_transcript_seq : dict
        A dictionary where keys are transcript names, and the values are the corresponding transcript sequences.
    """

    def __init__(
        self,
        dict_transcripts_assoc_orfs: dict,
        gene_name: str,
        dict_orf_seq: dict,
        dict_transcript_seq: dict,
    ) -> None:
        """
        Constructor for the Gene class.

        Parameters:
        - dict_transcripts_assoc_orfs: Dictionary with genes as keys and lists of associated ORFs as items.
        - gene_name: Name of the gene.
        - dict_orf_seq: Dictionary with ORF names as keys and their sequences as items.
        - dict_transcript_seq: Dictionary with transcript names as keys and their sequences as items.
        """
        self.dict_transcripts_assoc_orfs = dict_transcripts_assoc_orfs
        self.gene_name = gene_name
        self.dict_orf_seq = dict_orf_seq
        self.dict_transcript_seq = dict_transcript_seq

    def get_highest_kozac(
        self, dict_kozac_predicted_strg: dict, dict_kozac_relative_strg: dict
    ) -> None:
        """
        This method evaluates the Kozac sequence scores for ORFs in each transcript and selects the ORF(s) with
        the highest Kozac score for each transcript.

        For each transcript, it iterates through all associated ORFs and calculates the Kozac score for the
        Kozac sequence surrounding the start codon of each ORF. The ORF with the highest Kozac score is selected,
        and transcripts with no valid ORF (e.g., if the Kozac sequence is too close to the start of the transcript)
        are removed from the list of associated ORFs.

        Parameters:
        -----------
        dict_kozac_predicted_strg : dict
            A dictionary where keys are Kozac sequences (strings) and values are their corresponding Kozac scores.
            These scores represent the strength of the Kozac sequence prediction for each ORF.

        dict_kozac_relative_strg : dict
            A dictionary where keys are Kozac sequences (strings) and values represent some additional relevant data
            (e.g., relative position or strength in the context of Kozac sequence).

        Modifies:
        --------
        self.dict_transcripts_assoc_orfs : dict
            Updates the dictionary of transcripts and their associated ORFs. After this method runs, each transcript
            will only have the ORF(s) with the highest Kozac score, or will be removed from the dictionary if it doesn't
            have a valid ORF (e.g., if the Kozac sequence is too close to the start).

        list_transcript_to_remove : list
            A temporary list of transcripts that do not have a valid ORF with a Kozac score above the threshold. These
            transcripts are eventually removed from `self.dict_transcripts_assoc_orfs`.

        """
        list_transcript_to_remove = []
        # Iterate through transcripts with associated ORFs
        for transcript_name in self.dict_transcripts_assoc_orfs:
            best_kozac = 0
            highest_orf = []
            list_orfs = self.dict_transcripts_assoc_orfs[transcript_name]

            # Iterate through ORFs in the current transcript
            for orf_name in list_orfs:
                orf_start_0_python_indent = int(orf_name.split("_")[2]) - 1
                orf_start_3_python_indent = orf_start_0_python_indent + 3

                # Check if the ORF start is beyond the first 3 nucleotides
                if orf_start_0_python_indent > 3:
                    # Extract the Kozac sequence
                    my_kozac = self.dict_transcript_seq[transcript_name][
                        orf_start_0_python_indent - 4 : orf_start_3_python_indent + 1
                    ]
                    my_kozac = my_kozac.upper()

                    # Retrieve the Kozac score from the predicted dictionary
                    if my_kozac in dict_kozac_predicted_strg:
                        my_kozac_score = dict_kozac_predicted_strg[my_kozac]
                    else:
                        my_kozac_score = "na"

                    # Update the best Kozac score and associated ORFs
                    if my_kozac_score != "na" and my_kozac_score > best_kozac:
                        best_kozac = my_kozac_score
                        highest_orf = [orf_name]
                    elif my_kozac_score == best_kozac:
                        highest_orf.append(orf_name)

            # Update the transcript's associated ORFs with the highest Kozac score
            if len(highest_orf) > 0:
                self.dict_transcripts_assoc_orfs[transcript_name] = highest_orf
            else:
                # If the transcript only has an ORF and cannot have a Kozac score because it is too close to the start,
                # remove the transcript from the list of transcripts having an ORF.
                list_transcript_to_remove.append(transcript_name)

        # Remove transcripts without a valid ORF
        if len(list_transcript_to_remove) > 0:
            for transcript_name in list_transcript_to_remove:
                del self.dict_transcripts_assoc_orfs[transcript_name]

    def get_longest_orf(self) -> None:
        """
        This method identifies the longest ORF for each transcript and updates the transcript's associated ORFs
        to include only the longest one.

        For each transcript, the method iterates through all associated ORFs and calculates the length of each ORF.
        The longest ORF is selected, and the transcript's associated ORFs are updated to include only this longest ORF.

        Modifies:
        --------
        self.dict_transcripts_assoc_orfs : dict
            Updates the dictionary of transcripts and their associated ORFs. After this method runs, each transcript
            will only have the longest ORF associated with it, replacing any previously associated ORFs.

        """
        # Iterate through transcripts with associated ORFs
        for transcript_name in self.dict_transcripts_assoc_orfs:
            list_orfs = self.dict_transcripts_assoc_orfs[transcript_name]
            # Initialize variables to store information about the longest ORF
            max_orf_len = 0
            longest_orf = ""

            # Iterate through ORFs in the current transcript
            for orf_name in list_orfs:
                # Check the length of the current ORF
                if len(self.dict_orf_seq[orf_name]) > max_orf_len:
                    # Update information if the current ORF is longer
                    max_orf_len = len(self.dict_orf_seq[orf_name])
                    longest_orf = orf_name
            # Update the transcript's associated ORFs with the longest ORF
            if longest_orf != "":
                self.dict_transcripts_assoc_orfs[transcript_name] = [longest_orf]

    def get_start_first_orf(self) -> None:
        """
        This method identifies the first ORF (the one with the earliest start position) for each transcript and
        updates the transcript's associated ORFs to include only the first ORF.

        For each transcript, the method iterates through all associated ORFs and compares their start positions.
        The ORF with the earliest start position is selected, and the transcript's associated ORFs are updated to
        include only this ORF.

        Modifies:
        --------
        self.dict_transcripts_assoc_orfs : dict
            Updates the dictionary of transcripts and their associated ORFs. After this method runs, each transcript
            will only have the first ORF (the one with the earliest start position) associated with it.

        """
        # Iterate through transcripts with associated ORFs
        for transcript_name in self.dict_transcripts_assoc_orfs:
            list_orfs = self.dict_transcripts_assoc_orfs[transcript_name]

            # Initialize variables to store information about the first ORF
            orf_start_point = 10000000000000
            start_first_orf = ""

            # Iterate through ORFs in the current transcript
            for orf_name in list_orfs:
                # Extract the start position of the current ORF
                orf_start = int(orf_name.split("_")[2])

                # Check if the start position is earlier than the current recorded start point
                if orf_start < orf_start_point:
                    # Update information if the current ORF starts earlier
                    orf_start_point = orf_start
                    start_first_orf = orf_name

            # Update the transcript's associated ORFs with the first ORF
            if start_first_orf != "":
                self.dict_transcripts_assoc_orfs[transcript_name] = [start_first_orf]

    def min_size_utr(self, five_min: int, three_min: int) -> None:
        """
        This method filters the ORFs associated with each transcript based on their positions relative to the UTRs
        (Untranslated Regions) and the size criteria provided for both the 5' and 3' UTRs.

        For each transcript, it checks if the ORFs meet the minimum size criteria by ensuring that the ORF's start
        position is beyond the specified minimum length from the 5' UTR and the ORF's stop position is within the
        specified minimum length from the 3' UTR. Transcripts with ORFs that meet these criteria are retained,
        and those that don't are excluded.

        Parameters:
        ----------
        five_min : int
            The minimum distance (in nucleotides) from the 5' UTR required for an ORF to be considered valid.

        three_min : int
            The minimum distance (in nucleotides) from the 3' UTR required for an ORF to be considered valid.

        Modifies:
        --------
        self.final_dict_transcripts_assoc_orfs : dict
            This dictionary is populated with transcripts whose associated ORFs meet the size criteria.
            It is then copied back to the `dict_transcripts_assoc_orfs` attribute, effectively updating the ORF
            associations.

        Notes:
        ------
        - The method uses the start and stop positions of each ORF to evaluate whether it falls within the valid
          range specified by the 5' and 3' UTR size criteria.
        - After filtering, the ORFs that meet the size requirements are retained in `final_dict_transcripts_assoc_orfs`.
        - The method clears the original `dict_transcripts_assoc_orfs` and updates it with the filtered ORFs.

        """
        self.final_dict_transcripts_assoc_orfs = {}
        # Iterate through transcripts with associated ORFs
        for transcript_name in self.dict_transcripts_assoc_orfs:
            list_orfs = self.dict_transcripts_assoc_orfs[transcript_name]

            # Initialize lists to store information about ORFs that meet the size criteria
            new_list_orf = []

            # Iterate through ORFs in the current transcript
            for orf_name in list_orfs:
                # Extract the start and stop positions of the current ORF
                orf_start = int(orf_name.split("_")[2])
                orf_stop = int(orf_name.split("_")[3])

                # Extract the length of the current transcript
                transcript_length = len(self.dict_transcript_seq[transcript_name])

                # Check if the ORF meets the size criteria
                if orf_start > int(five_min) and orf_stop < (
                    transcript_length - int(three_min)
                ):
                    # Add the ORF to the new list if it meets the size criteria
                    new_list_orf.append(orf_name)

            # Update the transcript's associated ORFs with the filtered list of ORFs
            if len(new_list_orf) > 0:
                self.final_dict_transcripts_assoc_orfs[transcript_name] = new_list_orf
        self.dict_transcripts_assoc_orfs = {}
        self.dict_transcripts_assoc_orfs = self.final_dict_transcripts_assoc_orfs

    def handle_orf_duplicate_per_transcript(self) -> None:
        """
        This method handles duplicate ORFs within each transcript by ensuring that only unique ORF sequences are retained for each transcript.

        The function creates a reverse dictionary where ORF sequences are mapped to their corresponding ORF names. It then iterates through the dictionary, retaining only the unique ORF sequences and associating them back with the respective transcripts.

        The method ensures that for each transcript, only one copy of each unique ORF sequence is kept, effectively eliminating any duplicate ORF sequences.

        Modifies:
        --------
        self.dict_transcripts_assoc_orfs : dict
            This dictionary is updated to include only unique ORF sequences for each transcript, removing any duplicates. The updated dictionary is rebuilt using the reverse mapping of ORF sequences to ORF names.

        Notes:
        ------
        - The method works by first collecting all ORFs and their sequences into a reverse mapping. Then, only unique sequences are kept and reassigned to the corresponding transcripts.
        - The final result is that each transcript will have only unique ORFs (no duplicates).

        """
        dict_reverse_orf_to_transcript = {}

        # Iterate through transcripts with associated ORFs
        for transcript_name in self.dict_transcripts_assoc_orfs:
            list_orfs = self.dict_transcripts_assoc_orfs[transcript_name]

            # Iterate through ORFs in the current transcript
            for orf_name in list_orfs:
                # Extract the ORF sequence
                orf_seq = self.dict_orf_seq[orf_name]
                orf_seq = orf_seq.upper()
                # Map the ORF sequence to its ORF name in the reverse dictionary
                dict_reverse_orf_to_transcript[orf_seq] = orf_name

        # Reset the dictionary of associated ORFs for transcripts
        self.dict_transcripts_assoc_orfs = {}

        # Rebuild the dictionary using the reverse mapping of unique ORF sequences
        for orf_seq in dict_reverse_orf_to_transcript:
            orf_name = dict_reverse_orf_to_transcript[orf_seq]
            transcript_name = orf_name.split("_")[0]

            # Add the ORF name to the list of associated ORFs for the transcript
            if transcript_name not in self.dict_transcripts_assoc_orfs:
                self.dict_transcripts_assoc_orfs[transcript_name] = [orf_name]
            else:
                self.dict_transcripts_assoc_orfs[transcript_name].append(orf_name)


def generate_list_genes_objects(
    dict_gene_transcripts: dict,
    dict_transcript_orf: dict,
    dict_ORFs_fasta,
    dict_transcript_fasta: dict,
) -> list:
    """
    This function generates a list of Gene objects. Each Gene object contains information about the number of transcript variants (slice variants) for a gene,
    along with their associated ORFs. The function populates each Gene object with the gene's transcripts, associated ORFs, and their respective sequences.

    Parameters:
    -----------
    dict_gene_transcripts : dict
        A dictionary where the keys are gene names and the values are lists of associated transcript names for each gene.

    dict_transcript_orf : dict
        A dictionary where the keys are transcript names and the values are lists of associated ORF names for each transcript.

    dict_ORFs_fasta : dict
        A dictionary where the keys are ORF names and the values are the corresponding ORF sequences in FASTA format.

    dict_transcript_fasta : dict
        A dictionary where the keys are transcript names and the values are the corresponding transcript sequences in FASTA format.

    Returns:
    --------
    list_gene_object : list
        A list of Gene objects, each containing the gene's associated transcripts, their ORFs, and the corresponding sequences.
    """
    list_gene_object = []

    # Iterate through genes in the dictionary of gene transcripts
    for gene_name in dict_gene_transcripts:
        # Create a dictionary to store transcripts with associated ORFs
        dict_transcripts_with_orfs = {}

        # Get the list of transcripts for the current gene
        list_transcripts = dict_gene_transcripts[gene_name]

        # Iterate through transcripts
        for transcript_name in list_transcripts:
            # Check if the transcript has associated ORFs
            if transcript_name in dict_transcript_orf:
                # Add the transcript and its associated ORFs to the dictionary
                dict_transcripts_with_orfs[transcript_name] = dict_transcript_orf[
                    transcript_name
                ]

        # Check if there are transcripts with associated ORFs for the current gene
        if len(dict_transcripts_with_orfs) > 0:
            # Extract the name of the gene
            name_of_my_gene = gene_name

            # Create dictionaries to store transcript sequences and ORF sequences
            dict_transcript_seqs = {}
            dict_orf_seq = {}

            # Iterate through transcripts with associated ORFs
            for transcript_name in dict_transcripts_with_orfs:
                # Add the transcript sequence to the dictionary
                dict_transcript_seqs[transcript_name] = dict_transcript_fasta[
                    transcript_name
                ]

                # Iterate through ORFs associated with the current transcript
                for orf_name in dict_transcripts_with_orfs[transcript_name]:
                    # Add the ORF sequence to the dictionary
                    dict_orf_seq[orf_name] = dict_ORFs_fasta[orf_name]

            # Create a Gene object with the collected information and add it to the list
            gene_instance = Gene(
                dict_transcripts_with_orfs,
                name_of_my_gene,
                dict_orf_seq,
                dict_transcript_seqs,
            )
            list_gene_object.append(gene_instance)

    # Return the list of Gene objects
    return list_gene_object


def generate_dico_kozac() -> (dict, dict):
    """
    This function generates two dictionaries containing Kozac scores: one for predicted Kozac scores and another for relative Kozac strength.
    The function reads data from a Kozac prediction file and populates the dictionaries with Kozac sequences and their corresponding scores.

    The function assumes that the Kozac file is in CSV format where each line contains:
    - Kozac sequence
    - Predicted Kozac score (integer)
    - Relative Kozac strength (float)

    The function uses the predicted Kozac scores for further processing, but both predicted and relative strength scores are stored.

    Returns:
    --------
    dict_kozac_predicted_strg : dict
        A dictionary where the keys are Kozac sequences (strings) and the values are their corresponding predicted Kozac scores (integers).

    dict_kozac_relative_strg : dict
        A dictionary where the keys are Kozac sequences (strings) and the values are their corresponding relative Kozac strength values (floats).
    """
    # Initialize dictionaries to store Kozac scores
    dict_kozac_predicted_strg = {}
    dict_kozac_relative_strg = {}  # Note: I do not know which dict is the most relevant; so far, the program uses the dict predicted score.
    # Open the Kozac prediction file
    my_kozac_file = openFile("KCS-predicted.tsv")

    # Iterate through lines in the Kozac file
    for line in my_kozac_file[1:]:
        line = line.split("\n")[0]
        # Split line information into parts
        kozak_seq = line.split(",")[0]
        predicted_strg = int(line.split(",")[1])
        rel_strength = float(line.split(",")[2])

        # Populate the dictionaries with Kozac scores
        dict_kozac_predicted_strg[kozak_seq] = predicted_strg
        dict_kozac_relative_strg[kozak_seq] = rel_strength
    # Initialize a list to store transcripts to be removed
    return dict_kozac_predicted_strg, dict_kozac_relative_strg


def order_option_list(option_list: list) -> list:
    """
    Orders the given list of options based on a predefined priority:
    1. First, it selects the 'utr_size' options.
    2. Next, it adds the ORF selection options, which can be 'kozac_highest', 'start_first', or 'longest'.
    3. Finally, it includes the option related to handling duplicate ORFs ('duplicate_handle').

    This function ensures that the UTR size is prioritized first, followed by ORF selection criteria, and lastly handling duplicates.

    Parameters:
    -----------
    option_list : list of lists
        A list of options, where each option is represented as a sublist (e.g., `["utr_size", value]`, `["kozac_highest", value]`).

    Returns:
    --------
    ordered_option_list : list of lists
        A reordered list of options, following the priority order:
        - UTR size options first
        - ORF selection options (kozac_highest, start_first, longest)
        - Duplicate handling options last
    """
    ordered_option_list = []
    for sublist in option_list:
        if sublist[0] == "utr_size":
            ordered_option_list.append(sublist)
    for sublist in option_list:
        # no need to precise all orf because if nothing is precised by default all orfs are selected.
        if (
            sublist[0] == "kozac_highest"
            or sublist[0] == "start_first"
            or sublist[0] == "longest"
        ):
            ordered_option_list.append(sublist)
    for sublist in option_list:
        if sublist[0] == "duplicate_handle":
            ordered_option_list.append(sublist)
    return ordered_option_list


def sort_orfs_by_properties(
    filter_gene: bool,
    list_gene_object: list,
    option_list: list,
    dict_all_ORFs_purge1: dict,
    dict_gene_status: dict,
) -> (dict, dict):
    """
    This function processes a list of Gene objects and filters their associated ORFs based on specified properties.
    It handles the following filtering:
    - Selecting ORFs based on Kozac scores, ORF length, the first ORF, UTR size, and duplicate removal.
    - Only unique, non-overlapping ORFs from splice variants of a gene are kept.
    - Genes marked as "genic" in the provided gene status dictionary are discarded if `filter_gene` is set to True.

    Parameters:
    -----------
    filter_gene : bool
        If True, genes with a status of "genic" (as per `dict_gene_status`) will be discarded.

    list_gene_object : list of Gene
        A list of Gene objects, each containing transcripts and associated ORFs.

    option_list : list of lists
        A list of options specifying how the ORFs should be filtered. Each option is a sublist, where the first element indicates the filtering type (e.g., `kozac_highest`, `longest`, `utr_size`, `duplicate_handle`), and subsequent elements specify the parameters for that filter.

    dict_all_ORFs_purge1 : dict
        A dictionary containing all ORFs, where the key is the ORF name and the value is its sequence.

    dict_gene_status : dict
        A dictionary mapping gene names to their status (e.g., `"genic"`, `"denovo"`) that determines whether to discard the gene.

    Returns:
    --------
    dict_transcrit_filtered_orfs : dict
        A dictionary with transcript names as keys and lists of associated filtered ORFs as values.

    dict_all_ORFs_filtered : dict
        A dictionary with ORF names as keys and their sequences as values, containing only the filtered ORFs.
    """
    dict_transcrit_filtered_orfs = {}
    dict_all_ORFs_filtered = {}
    dict_kozac_predicted_strg, dict_kozac_relative_strg = generate_dico_kozac()
    ordered_option_list = order_option_list(option_list)
    # Iterate through each Gene object in the list
    for gene_object in list_gene_object:
        # Iterate through each option in the provided list of options
        discard_gene = False
        for option in ordered_option_list:
            # Check the type of option and call the corresponding method in the Gene object
            if option[0] == "kozac_highest":
                gene_object.get_highest_kozac(
                    dict_kozac_predicted_strg, dict_kozac_relative_strg
                )
            elif option[0] == "longest":
                gene_object.get_longest_orf()
            elif option[0] == "start_first":
                gene_object.get_start_first_orf()
            elif option[0] == "utr_size":
                gene_object.min_size_utr(option[1], option[2])
            elif option[0] == "duplicate_handle":
                gene_object.handle_orf_duplicate_per_transcript()
            if filter_gene == True:
                if dict_gene_status[gene_object.gene_name] == "genic":
                    discard_gene = True

        # Iterate through the transcripts associated with the current Gene object (is the user want a denovo gene, only these will be written)
        if discard_gene == False:
            for transcript_name in gene_object.dict_transcripts_assoc_orfs:
                # Update the dictionary with filtered transcripts and associated ORFs
                dict_transcrit_filtered_orfs[transcript_name] = (
                    gene_object.dict_transcripts_assoc_orfs[transcript_name]
                )

                # Iterate through the associated ORFs and update the dictionary with all filtered ORFs
                for orf_name in gene_object.dict_transcripts_assoc_orfs[
                    transcript_name
                ]:
                    dict_all_ORFs_filtered[orf_name] = dict_all_ORFs_purge1[orf_name]

    # Return the dictionaries with filtered transcripts and all filtered ORFs
    return dict_transcrit_filtered_orfs, dict_all_ORFs_filtered
